---
title: Architecture Overview
description: AOF's architecture — module boundaries, data flows, and design decisions for contributors.
sidebar:
  order: 4
---

import { Aside } from '@astrojs/starlight/components';

This page describes AOF's internal architecture for contributors. Understanding these boundaries will help you make changes without introducing coupling or breaking invariants.

## Core Invariants

1. **Tasks are the only shared state** — modules communicate via the task store, not direct calls
2. **Atomic state transitions** — all status changes are filesystem `rename()` — no partial states
3. **Deterministic scheduler** — no LLM calls in the hot path; pure business logic
4. **Schema-first** — Zod schemas in `src/schemas/` are the source of truth for all data shapes
5. **No god files** — modules are small (&lt;400 LOC), composable, with clean public APIs

## Module Map

```
src/
├── schemas/        Source of truth for all data shapes (Zod)
├── store/          Filesystem task store (read/write/transition)
├── dispatch/       Scheduler, gate evaluator, SLA, leases, deps
├── protocol/       Protocol router (handoff, resume, completion)
├── events/         Event logger (JSONL) + notification service
├── tools/          Agent tool implementations (thin wrappers over store)
├── mcp/            MCP server adapter (wraps tools for MCP clients)
├── org/            Org-chart parser, validator, linter, drift detection
├── memory/         Medallion pipeline + HNSW vector index
├── metrics/        Prometheus metrics
├── cli/            CLI command registration (Commander.js)
├── daemon/         Background daemon (HTTP health + scheduler loop)
├── views/          Kanban + mailbox view generation
├── recovery/       Task resurrection, deadletter handling
├── context/        Context assembly, skill loading, budget management
├── config/         Configuration loading + validation
└── openclaw/       OpenClaw gateway adapter (plugin mode)
```

## Data Flow: Task Dispatch

```
Agent calls aof_dispatch
       │
       ▼
tools/project-tools.ts::aofDispatch()
       │  creates task
       ▼
store/task-store.ts::create()
       │  writes file to tasks/backlog/
       │  transitions to ready
       ▼
Scheduler poll (dispatch/scheduler.ts::poll())
       │  selects task, acquires lease
       │  atomically renames to in-progress/
       ▼
dispatch/task-dispatcher.ts::dispatch()
       │  looks up agent in org chart
       │  calls OpenClaw gateway (spawn/send)
       ▼
Agent session starts
       │  reads task file
       │  does work
       │  calls aof_task_complete
       ▼
tools/task-workflow-tools.ts::aofTaskComplete()
       │  validates gate requirements
       │  dispatches gate-transition-handler if gated
       ▼
dispatch/gate-transition-handler.ts
       │  calls gate-evaluator for role validation
       │  advances or rejects gate
       ▼
store/task-store.ts::transition() → rename() to done/review/blocked/
       ▼
events/logger.ts → JSONL event log
events/notifier.ts → notifications (Matrix, console)
dispatch/dep-cascader.ts → unblock dependent tasks
```

## Key Abstractions

### ITaskStore

The task store interface (`src/store/interfaces.ts`) is the central abstraction. All components depend on `ITaskStore`, not the concrete `FilesystemTaskStore`. This enables:
- Testing with in-memory stores
- Future backends (SQLite, PostgreSQL) without touching callers

Core operations:
```typescript
interface ITaskStore {
  create(input): Promise<Task>
  get(id): Promise<Task | undefined>
  getByPrefix(prefix): Promise<Task | undefined>
  list(opts?): Promise<Task[]>
  transition(id, status): Promise<Task>
  update(id, patch): Promise<Task>
  delete(id): Promise<void>
  lint(): Promise<Array<{task: Task, issue: string}>>
}
```

### GateEvaluator

The gate evaluator (`src/dispatch/gate-evaluator.ts`) is the single enforcement point for all gate logic:
- Role validation (`callerRole` must match gate's `role`)
- `canReject` checks
- Conditional gate evaluation
- Outcome validation

All gate transitions go through `gate-evaluator.ts`. No other module should implement gate logic.

### NotificationService

The notification service (`src/events/notifier.ts`) receives events and routes to configured adapters. It's the only module allowed to call notification adapters — other modules emit events, not notifications.

## Design Patterns

### Table-Driven Logic

When you see >3 similar branches, use a table:

```typescript
// ✅ Good
const OUTCOME_HANDLERS: Record<GateOutcome, OutcomeHandler> = {
  complete: handleComplete,
  needs_review: handleNeedsReview,
  blocked: handleBlocked,
};

// ✗ Bad (scattered branching)
if (outcome === "complete") handleComplete();
else if (outcome === "needs_review") handleNeedsReview();
else if (outcome === "blocked") handleBlocked();
```

### Interface-First

Define the contract before the implementation:

```typescript
// ✅ Define interface first
export interface IMemoryStore {
  search(query: string, opts?: SearchOpts): Promise<SearchResult[]>
  write(entry: MemoryEntry): Promise<void>
}

// Then implement
export class FilesystemMemoryStore implements IMemoryStore {
  // ...
}
```

### Composition Over Inheritance

Use wrappers and decorators, not class hierarchies:

```typescript
// ✅ Wrapper pattern
class PermissionAwareTaskStore implements ITaskStore {
  constructor(private inner: ITaskStore, private policy: Policy) {}
  
  async get(id: string) {
    const task = await this.inner.get(id);
    if (!this.policy.canRead(task)) throw new ForbiddenError();
    return task;
  }
}
```

## Size Budget (Hard Limits)

AOF enforces strict file size limits:

| Threshold | Action |
|-----------|--------|
| >400 LOC | Refactor first — extract a module |
| >500 LOC | **Refuse to add code** — split the file |
| Function >80 LOC | Extract helpers |
| Function >120 LOC | **Must decompose** |

If you need to add code to a file over 400 LOC, split it first into focused submodules, then add your code to the appropriate new module.

## Testing Philosophy

- **Unit tests** in `src/<module>/__tests__/` — test pure functions and small components in isolation
- **Integration tests** in `tests/` — test module interactions with real (temp) filesystem
- **E2E tests** in `tests/` with `vitest.e2e.config.ts` — require running OpenClaw

Every public API should have tests. Gate enforcement logic in particular has extensive tests (`src/dispatch/__tests__/gate-enforcement.test.ts` — 22 tests covering role, canReject, conditional, and full pipeline).

<Aside type="tip">
Before adding a new feature, check `src/schemas/` to see if a schema already exists for your data shape. Zod schemas are the source of truth — derive TypeScript types from them, not the other way around.
</Aside>
