---
title: Protocol System
description: Structured inter-agent communication for task handoff, resume, and completion in AOF.
sidebar:
  order: 5
---

import { Aside } from '@astrojs/starlight/components';

The AOF protocol system provides **structured, typed inter-agent communication** for task lifecycle events. Instead of ad-hoc messages, all agent communication uses a standardized JSON envelope that the protocol router can parse, validate, and act on.

## Why Protocols?

AOF is filesystem-first and deterministic. Protocols enforce:

- **Predictable state transitions** — no stochastic behavior; all state changes are explicit
- **Crash recovery** — tasks can resume safely after agent interruptions
- **Audit trail** — all messages are logged with timestamps and actor identities
- **Decoupled communication** — agents don't need direct connections; state lives on disk

## Protocol Envelope

All messages share a common JSON envelope:

```json
{
  "protocol": "aof",
  "version": 1,
  "type": "completion.report",
  "taskId": "TASK-2026-02-21-001",
  "fromAgent": "swe-backend",
  "toAgent": "dispatcher",
  "sentAt": "2026-02-21T15:00:00.000Z",
  "payload": {
    "outcome": "complete",
    "summary": "Feature implemented and tested",
    "outputs": ["src/auth/middleware.ts", "tests/auth.test.ts"]
  }
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `protocol` | `"aof"` | ✅ | Protocol identifier |
| `version` | `1` | ✅ | Protocol version |
| `type` | string | ✅ | Message type (see below) |
| `taskId` | string | ✅ | Task this message relates to |
| `fromAgent` | string | ✅ | Sending agent ID |
| `toAgent` | string | ✅ | Receiving agent/role |
| `sentAt` | ISO-8601 | ✅ | Message timestamp |
| `payload` | object | ✅ | Type-specific payload |

## Message Types

| Type | Direction | Description |
|------|-----------|-------------|
| `completion.report` | Agent → Dispatcher | Task work complete |
| `status.update` | Agent → Dispatcher | Mid-task progress update |
| `handoff.request` | Agent A → Agent B | Delegate task to another agent |
| `handoff.accepted` | Agent B → Agent A | Accept delegation |
| `handoff.rejected` | Agent B → Agent A | Decline delegation |
| `resume` | Dispatcher → Agent | Re-entry after interruption |

## Completion Report

The most common protocol message — signals that an agent has finished work:

```json
{
  "type": "completion.report",
  "taskId": "TASK-2026-02-21-001",
  "fromAgent": "swe-backend",
  "toAgent": "dispatcher",
  "payload": {
    "outcome": "complete",
    "summary": "Implemented rate limiting with token bucket algorithm",
    "outputs": [
      "src/middleware/rate-limit.ts",
      "tests/rate-limit.test.ts"
    ],
    "workLog": [
      "Reviewed existing auth flow",
      "Implemented token bucket with Redis fallback",
      "Added 12 unit tests"
    ]
  }
}
```

**Outcomes:**
- `complete` — Work done, advance in workflow
- `blocked` — External dependency, cannot proceed
- `needs_review` — Work done but has issues, needs revision
- `partial` — Partial work done, task continues with another agent

## Status Update

Mid-task progress reports — keep the task record current without completing:

```json
{
  "type": "status.update",
  "taskId": "TASK-2026-02-21-001",
  "fromAgent": "swe-backend",
  "payload": {
    "workLog": "Completed database schema migration, starting API layer",
    "progress": 60,
    "estimatedCompletionMinutes": 45
  }
}
```

## Handoff Protocol

Allows an agent to delegate a task to another agent:

```
Agent A                    AOF Router                    Agent B
   │                           │                            │
   │── handoff.request ────────►│                            │
   │   (task, context,          │── Route to Agent B ───────►│
   │    acceptance criteria)    │                            │
   │                            │◄──── handoff.accepted ────│
   │◄── Routing updated ───────│       (or rejected)        │
   │                            │                            │
```

### Handoff Request

```json
{
  "type": "handoff.request",
  "taskId": "TASK-2026-02-21-001",
  "fromAgent": "swe-backend",
  "toAgent": "swe-devops",
  "payload": {
    "reason": "Deployment requires DevOps tooling access",
    "context": "Auth service built and tested. Needs Docker deployment.",
    "acceptanceCriteria": [
      "Service deployed to staging",
      "Health check passing",
      "Environment variables configured"
    ],
    "expiresAt": "2026-02-21T18:00:00Z"
  }
}
```

### Handoff Accepted

```json
{
  "type": "handoff.accepted",
  "taskId": "TASK-2026-02-21-001",
  "fromAgent": "swe-devops",
  "toAgent": "swe-backend",
  "payload": {
    "message": "Taking over deployment. ETA 30 minutes."
  }
}
```

When accepted:
- `routing.agent` is updated to the receiving agent
- The task lease is transferred
- A `handoff.completed` event is logged

### Handoff Rejected

```json
{
  "type": "handoff.rejected",
  "taskId": "TASK-2026-02-21-001",
  "fromAgent": "swe-devops",
  "toAgent": "swe-backend",
  "payload": {
    "reason": "Currently at capacity, try again in 2 hours",
    "suggestAlternative": "swe-platform"
  }
}
```

## Resume Protocol

Enables deterministic re-entry after an agent interruption:

```json
{
  "type": "resume",
  "taskId": "TASK-2026-02-21-001",
  "fromAgent": "dispatcher",
  "toAgent": "swe-backend",
  "payload": {
    "context": "Previous session ended unexpectedly. Last work log: 'Completed schema migration, starting API layer'",
    "checkpoint": {
      "progress": 60,
      "completedSteps": ["schema-migration", "test-data"],
      "nextStep": "api-layer"
    }
  }
}
```

The resume message is generated from the task's `run_result.json` artifact — a JSON file written by the agent to record its progress. AOF reads this file when restarting a task and synthesizes a resume protocol message.

## Run Artifacts

Each dispatched task generates run artifacts on disk:

```
tasks/in-progress/TASK-2026-02-21-001.md
runs/TASK-2026-02-21-001/
├── run.json          # Dispatch metadata (status: "running")
├── run_heartbeat.json # Last heartbeat timestamp
└── run_result.json   # Written on completion (for recovery)
```

`run.json` structure:
```json
{
  "taskId": "TASK-2026-02-21-001",
  "sessionId": "session-abc123",
  "agent": "swe-backend",
  "startedAt": "2026-02-21T15:00:00Z",
  "status": "running"
}
```

## Protocol Router

The protocol router (`src/protocol/router.ts`) receives incoming messages and:
1. Validates the envelope schema
2. Routes by `type` to the appropriate handler
3. Applies state transitions (via task store)
4. Emits events to the event log
5. Sends notifications via the notification engine

<Aside type="tip">
In practice, most agents don't construct protocol envelopes directly — they call AOF tools (`aof_task_complete`, `aof_task_update`) which construct and route the messages internally. The protocol format is documented here for implementers building direct integrations.
</Aside>
